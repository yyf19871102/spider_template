/**
 * @author yangyufei
 * @date 2019-03-13 14:39:47
 * @desc
 */
const {EventEmitter}    = require('events');
const moment            = require('moment');
const fs                = require('fs');
const path              = require('path');
const mkdirp            = require('mkdirp');
const Promise           = require('bluebird');
const readline          = require('readline');

const validator         = require('./validator');

class FailedTasksHandler extends EventEmitter {
    constructor(config) {
        super();

        validator.validate(config);

        this.config = config;
        this.startTime = null;
        this.endTime = null;
        this.exitType = null;

        this.destPath = null;

        this.summary = {};
    }

    _buildDir() {
        if (!fs.existsSync(this.destPath)) {
            this.destPath = path.join(this.config.destDir, this.config.spiderKey, this.config.jobId);

            mkdirp.sync(this.destPath);
        }
    }

    startJob() {
        !this.startTime && (this.startTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS'));
    }

    endJob(exitType = 'success') {
        this._buildDir();

        this.endTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        this.exitType = exitType;

        fs.writeFile(path.join(this.destPath, 'meta.json'), JSON.stringify({
            jobId       : this.config.jobId,
            parentId    : this.config.parentId,
            startTime   : this.startTime,
            endTime     : this.endTime,
            exitType    : this.exitType,
            summary     : this.summary
        }, null, 4), () => {});
    }

    saveTask(phaseName, taskObj) {
        this._buildDir();

        this.summary[phaseName] ? (this.summary[phaseName] += 1) : (this.summary[phaseName] = 1);

        fs.appendFile(path.join(this.destPath, `${phaseName}.fail`), `${JSON.stringify(taskObj)}\r\n`, () => {});
    }

    async runFailedTask(phaseName, handler) {
        const rl = readline.createInterface({
            input: fs.createReadStream(path.join(this.destPath, `${phaseName}.fail`)),
            crlfDelay: Infinity
        });

        await new Promise((resolve, reject) => {
            rl.on('line', async line => {
                try {
                    await handler(JSON.parse(line));
                } catch (err) {
                    resolve(err);
                }
            });

            rl.on('close', resolve);
        });
    }
}

exports.getInstance = config => new FailedTasksHandler(config);